import numpy as np
import matplotlib.pyplot as plt
import pdb
from scipy.integrate import solve_ivp
import DDSafe_fcn as DDS
import LQR_CBF as LC
import sys
sys.path.append('/Users/zheng/Desktop/researchCTRL-Leung/Code/DataDriveSafeControl/DDSafe')

def main():
# Initilize Simulation parameters
#Time simulation parameters
    t_initial = 0
    t_end = 100  # Time span (s)
    dt = 0.1  # Time step
    t_range = np.arange(0, t_end + dt, dt)
    n_states = len(t_range)

#how close is the vehicle and obstacle before simulation stops. 
    dist_threshold = 0.01

#Initial states of vehicle and goal
    state = np.array([[0],[0],[0],[0]])
    robot_radius = 0.25
    goal_position = np.array([[5],[5]])

#obtacle information
    obs_radius = 1
    obs_x = 2.5
    obs_y = 2.5
    obs = (obs_x, obs_y, obs_radius)

#Nominal control input genetion PD parameter
    Kp = np.array([[2, 0], [0, 1]])
    Kd = np.array([[2, 0], [0, 1]])

#LQR State/Input cost matrix 
    '''
    Q penalises large differences between where you want the car to be vs where it is right now. 
    Q enables us to target states where we want low error by making the corresponding value of Q large.
    Q has positive values along the diagonal and zeros elsewhere.
    '''
    Q = np.array([[1, 0, 0, 0],[0, 1.0, 0,0], [0, 0, 1.0,0], [0,0,0,1.0]])    
    R = np.array([[0.1, 0],[0, 0.1]])
    max_acceleration = 1.5

#CBF parameters
    safety_dist = 0.3
    gamma_fcn = 0.2

#Other Coding Parameter initilization
    state_list = []
    u_list = []



    for i,t in enumerate(t_range):
        state_list.append(state.tolist())
        # control input u generated by proportional_derivative controller 
        # Use this as the nominal control input 
        u_PD = DDS.PD_controller(Kp, Kd, state, goal_position)

        #control input u generated by cbf controller
        u_lqr = LC.lqr_controller(state, goal_position, Q, R, dt, max_acceleration)

        #control input u generated by cbf controller
        u_safe = LC.cbf_controller(state, obs, robot_radius, safety_dist, u_lqr, gamma_fcn, dt)

        #Update states given control input u - u is np.array[[a1],[a2]]
        state = DDS.double_integrator_dynamics(state, u_lqr, dt)
        print(state)
        u_list.append(u_safe.tolist())
        if DDS.euclidean_distance(state[0:2],goal_position) < dist_threshold:
            break
        #pdb.set_trace()
    # print(u_list)
    # print(state_list)
    state_array = np.array(state_list)

#Plotting!
    print("start!")
    #Plot goal
    goal_x, goal_y = DDS.plot_goal(center = goal_position, radius=0.2, obs = None)
    obs_x, obs_y = DDS.plot_goal(obs=obs, center=None, radius=None)
    plt.plot(obs_x, obs_y, label = 'obstacle', color = 'blue')
    plt.plot(goal_x, goal_y, label = 'goal', color = 'red')
    plt.scatter(goal_position[0], goal_position[1], color='red', marker='x', label='Goal Position')
    # Plot the trajectory  
    #plt.plot(state_array.reshape(len(state_array),4)[:,0], state_array.reshape(len(state_array),4)[:,1],label='Trajectory')  
    trajectory_line, = plt.plot([], [], label='Trajectory')
    plt.title('Vehicle Trajectory')
    plt.xlabel('PositionX')
    plt.ylabel('PositionY')
    plt.legend()
    plt.xlim(0,6)
    plt.ylim(0,6)
    plt.grid(True)


    for i in range(len(state_array)):
        trajectory_line.set_xdata(state_array.reshape(len(state_array),4)[:i,0])
        trajectory_line.set_ydata(state_array.reshape(len(state_array),4)[:i,1])
        plt.pause(0.1)
    plt.pause(2)
    plt.show()


if __name__ == "__main__":
    main()